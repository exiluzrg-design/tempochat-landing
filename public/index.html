// Runtime: Vercel Node 20.x
// PRIVACIDAD: no se guarda texto de usuarios en la base.
// Solo se guardan palabras clave agregadas (analytics_topics) vía RPC inc_topics().

const OPENAI_URL = process.env.OPENAI_URL || 'https://api.openai.com/v1/chat/completions';
const OPENAI_MODEL = process.env.OPENAI_MODEL || 'gpt-4o-mini';
const OPENAI_API_KEY = process.env.OPENAI_API_KEY;

const SUPABASE_URL = process.env.SUPABASE_URL || process.env.NEXT_PUBLIC_SUPABASE_URL;
const SUPABASE_SERVICE_ROLE_KEY = process.env.SUPABASE_SERVICE_ROLE_KEY;

const SESSIONS = `${SUPABASE_URL}/rest/v1/sessions`;
const TOPICS   = `${SUPABASE_URL}/rest/v1/analytics_topics`;
const RPC_INC  = `${SUPABASE_URL}/rest/v1/rpc/inc_topics`;

const T_SESSION_MIN = parseInt(process.env.SESSION_MIN || '10', 10);

function cors(){ return { 'Access-Control-Allow-Origin': '*', 'Access-Control-Allow-Methods':'GET,POST,OPTIONS', 'Access-Control-Allow-Headers':'Content-Type,Authorization' }; }
const sbAuth = { 'Authorization': `Bearer ${SUPABASE_SERVICE_ROLE_KEY}` };
function ok(res, data){ return res.status(200).json(data); }
function bad(res, code, message, status=400){ return res.status(status).json({ error: code, message }); }
function newSessionId(){ return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g,c=>{const r=(Math.random()*16)|0,v=c==='x'?r:(r&0x3|0x8);return v.toString(16)}); }

// ---------- Sesiones (solo id/expiración, sin texto) ----------
async function sbGetSession(sessionId){
  const url = new URL(SESSIONS);
  url.searchParams.set('select','session_id,expires_at,started_at');
  url.searchParams.set('session_id','eq.'+sessionId);
  const r = await fetch(url, { headers: sbAuth });
  if(!r.ok) throw new Error(`get_session_failed: ${r.status} ${await r.text()}`);
  const j = await r.json();
  return j[0];
}
async function sbCreateSession(sessionId){
  const expiresAt = new Date(Date.now() + T_SESSION_MIN*60*1000).toISOString();
  const payload = { session_id: sessionId, expires_at: expiresAt };
  const r = await fetch(SESSIONS, { method:'POST', headers:{...sbAuth, 'Content-Type':'application/json', 'Prefer':'return=representation'}, body: JSON.stringify(payload) });
  if(!r.ok) throw new Error(`create_session_failed: ${r.status} ${await r.text()}`);
  return (await r.json())[0];
}
async function sbEndSession(sessionId){
  await fetch(`${SESSIONS}?session_id=eq.${sessionId}`, { method:'DELETE', headers: sbAuth });
}

// ---------- Tags (solo palabras clave agregadas, sin PII) ----------
const TAGS = [
  { tag:'infidelidad', rx: /(infidelidad|infiel|engaño|cuernos?|traici[oó]n)/i },
  { tag:'pareja',      rx: /(pareja|novi[oa]|matrimonio|relaci[oó]n)/i },
  { tag:'separacion',  rx: /(separaci[oó]n|divorcio|ruptura)/i },
  { tag:'ansiedad',    rx: /(ansiedad|ansioso|ataque de p[aá]nico|palpitaciones)/i },
  { tag:'estrés',      rx: /(estr[eé]s|estresado|estresante)/i },
  { tag:'culpa',       rx: /(culpa|culpable)/i },
  { tag:'miedo',       rx: /(miedo|temor|p[áa]nico)/i },
  { tag:'autoestima',  rx: /(autoestima|inseguridad|val[ií]a)/i },
  { tag:'duelo',       rx: /(duelo|p[eé]rdida|luto)/i },
  { tag:'trabajo',     rx: /(trabajo|oficina|jefe|equipo|burnout)/i },
  { tag:'productividad', rx: /(productividad|organizar|procrastinaci[oó]n|priorizar)/i },
  { tag:'carrera',     rx: /(carrera|profesi[oó]n|promoci[oó]n|cambio laboral)/i },
  { tag:'dinero',      rx: /(dinero|deudas?|finanzas|gastos)/i },
  { tag:'familia',     rx: /(familia|hij[oa]s?|madre|padre|herman[oa]s?)/i },
  { tag:'amigos',      rx: /(amig[oa]s?|amistad)/i },
];
function extractTags(text){
  if(!text) return [];
  const found = [];
  for(const t of TAGS){
    if(t.rx.test(text)){
      if(!found.includes(t.tag)) found.push(t.tag);
      if(found.length >= 3) break; // límite práctico
    }
  }
  return found;
}
async function sbIncTopics(tags){
  if(!tags || !tags.length) return;
  const r = await fetch(RPC_INC, {
    method:'POST',
    headers:{ ...sbAuth, 'Content-Type':'application/json' },
    body: JSON.stringify({ p_tags: tags })
  });
  if(!r.ok) throw new Error(`inc_topics_failed: ${r.status} ${await r.text()}`);
}
async function sbTopTags(limit=5){
  const url = new URL(TOPICS);
  url.searchParams.set('select','tag,count,last_seen');
  url.searchParams.set('order','count.desc,last_seen.desc');
  url.searchParams.set('limit', String(limit));
  const r = await fetch(url, { headers: sbAuth });
  if(!r.ok) return [];
  return r.json();
}

// ---------- OpenAI ----------
async function callOpenAI(userText, trendHints){
  const sysBase = [
    'Sos TempoChat, un acompañante breve y cálido.',
    'Hablá en español rioplatense.',
    'Evitá más de 6 oraciones por respuesta.',
    'No reveles ni insinúes que existen “tendencias” o datos de otras personas.'
  ].join(' ');
  const sysTrends = trendHints?.length
    ? `Pistas internas: ${trendHints.join(', ')}. Usalas solo si son pertinentes; nunca digas que son tendencias.`
    : '';

  const messages = [
    { role:'system', content: `${sysBase} ${sysTrends}` },
    { role:'user',   content: userText }
  ];

  const r = await fetch(OPENAI_URL, {
    method:'POST',
    headers:{ 'Content-Type':'application/json', 'Authorization': `Bearer ${OPENAI_API_KEY}` },
    body: JSON.stringify({ model: OPENAI_MODEL, messages, temperature: 0.6 })
  });
  const txt = await r.text();
  if(!r.ok) throw new Error(`openai_error: ${r.status} ${txt}`);
  const j = JSON.parse(txt);
  return j.choices?.[0]?.message?.content?.trim() || '';
}

// ---------- Handler ----------
export default async function handler(req, res){
  if(req.method==='OPTIONS') return res.set(cors()).status(204).end();
  res.set(cors());

  try{
    if(req.method!=='POST') return bad(res,'method_not_allowed','Use POST',405);
    if(!SUPABASE_URL || !SUPABASE_SERVICE_ROLE_KEY) return bad(res,'config','Supabase no configurado');
    if(!OPENAI_API_KEY) return bad(res,'config','Falta OPENAI_API_KEY');

    const body = typeof req.body==='object'? req.body : JSON.parse(req.body||'{}');
    const text = (body.text||'').toString().trim();
    let { sessionId } = body;
    if(!text) return bad(res,'no_text','Texto vacío');

    if(!sessionId) sessionId = newSessionId();
    let ses = await sbGetSession(sessionId);
    if(!ses) ses = await sbCreateSession(sessionId);

    const now = Date.now();
    const exp = new Date(ses.expires_at).getTime();
    if(now > exp){
      await sbEndSession(sessionId);
      return bad(res,'session_expired','La sesión ya terminó. Iniciá una nueva.',410);
    }

    // 1) Extraer tags locales y actualizar tendencias agregadas (SIN guardar texto)
    const tags = extractTags(text);
    if(tags.length) await sbIncTopics(tags);

    // 2) Traer top tags como pistas internas
    const top = await sbTopTags(5);
    const trendHints = (top||[]).map(t => t.tag);

    // 3) Responder con OpenAI (texto no se persiste en ningún lado de tu BD)
    const assistant = await callOpenAI(text, trendHints);

    // No logueamos texto (por privacidad). Si necesitás debug, logueá solo longitud:
    // console.log({ len: text.length, tags });

    return ok(res, { sessionId, message: assistant, expiresAt: ses.expires_at, tagsUsed: tags, version:'v-keywords-only' });
  }catch(err){
    return bad(res,'server_error', String(err?.message||err));
  }
}
