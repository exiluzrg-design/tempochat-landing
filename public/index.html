// Etapa 4.1 (debug) — api/chat.js
export default async function handler(req, res) {
  const respond = (obj) => {
    res.setHeader('Access-Control-Allow-Origin', '*');
    return res.status(200).json(obj);
  };

  try {
    // CORS + preflight
    res.setHeader('Access-Control-Allow-Origin', '*');
    if (req.method === 'OPTIONS') {
      res.setHeader('Access-Control-Allow-Methods', 'POST, OPTIONS');
      res.setHeader('Access-Control-Allow-Headers', 'Content-Type');
      return res.status(204).end();
    }
    if (req.method !== 'POST') {
      return res.status(405).json({ ok: false, error: 'method not allowed' });
    }

    // Parseo defensivo del body
    let body = {};
    try {
      body = typeof req.body === 'string'
        ? JSON.parse(req.body || '{}')
        : (req.body || {});
    } catch { body = {}; }

    const text = (body.text || '').toString();
    let sessionId = (body.sessionId || '').toString().trim();
    if (!sessionId) {
      sessionId = (globalThis.crypto?.randomUUID?.() || 'sid-' + Math.random().toString(36).slice(2));
    }

    // Fallback local
    let reply = text
      ? 'Te sigo. Si tuvieras que nombrar el obstáculo en una frase, ¿cuál sería?'
      : 'Arranquemos con lo que te preocupa en una oración.';

    // OpenAI opcional (sin cambiar respecto a Etapa 4)
    let usedOpenAI = false;
    let openai_error = null;
    if (process.env.OPENAI_API_KEY) {
      try {
        const ctrl = new AbortController();
        const to = setTimeout(() => ctrl.abort(), 15000);
        const r = await fetch('https://api.openai.com/v1/chat/completions', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            Authorization: `Bearer ${process.env.OPENAI_API_KEY}`,
          },
          body: JSON.stringify({
            model: 'gpt-4o-mini',
            max_tokens: 220,
            messages: [
              { role: 'system', content: 'Hablá con conocimiento psicológico y olfato de calle; tono cálido rioplatense, directo y cercano. No digas tu profesión.' },
              { role: 'user', content: text || 'ping' },
            ],
          }),
          signal: ctrl.signal,
        });
        clearTimeout(to);
        const raw = await r.text();
        let data; try { data = JSON.parse(raw); } catch { data = { raw }; }
        if (r.ok && data?.choices?.[0]?.message?.content) {
          reply = String(data.choices[0].message.content).trim();
          usedOpenAI = true;
        } else {
          openai_error = data?.error?.message || r.statusText || 'openai not ok';
        }
      } catch (e) {
        openai_error = e?.message || 'openai timeout/network';
      }
    }

    // Supabase opcional (privacy-first)
    const SAVE_TEXT = String(process.env.SAVE_TEXT || 'false').toLowerCase() === 'true';
    const hasSbUrl = !!process.env.SUPABASE_URL;
    const hasSbKey = !!(process.env.SUPABASE_SERVICE_ROLE_KEY || process.env.SUPABASE_ANON_KEY);

    const envFlags = {
      OPENAI_API_KEY: !!process.env.OPENAI_API_KEY,
      SUPABASE_URL: hasSbUrl,
      SUPABASE_SERVICE_ROLE_KEY: !!process.env.SUPABASE_SERVICE_ROLE_KEY,
      SUPABASE_ANON_KEY: !!process.env.SUPABASE_ANON_KEY,
      SAVE_TEXT: SAVE_TEXT,
    };

    let saved = false;
    let savedAttempted = false;
    let supabase_error = null;
    let moduleSupabase = null;

    // Tagging simple
    function extractTags(s) {
      const tags = [];
      const lower = (s || '').toLowerCase();
      if (!lower) return ['general'];
      if (/\btrabajo|laburo|oficina|jefe|empleo\b/.test(lower)) tags.push('trabajo');
      if (/\bpareja|relación|amor|separación|novia|novio\b/.test(lower)) tags.push('vínculos');
      if (/\bansiedad|estrés|miedo|angustia|enojo\b/.test(lower)) tags.push('emociones');
      if (/\bdecisión|dudar|elección\b/.test(lower)) tags.push('decisiones');
      if (tags.length === 0) tags.push('general');
      return Array.from(new Set(tags)).slice(0, 3);
    }
    const userTags = extractTags(text);
    const assistantTags = extractTags(reply);

    if (hasSbUrl && hasSbKey) {
      try {
        // 1) import dinámico — si falla, vemos el error
        const mod = await import('@supabase/supabase-js').catch(e => { throw new Error('import_supabase_failed: ' + (e?.message || e)); });
        moduleSupabase = Object.keys(mod || {});
        const { createClient } = mod;

        // 2) cliente
        const sb = createClient(
          process.env.SUPABASE_URL,
          process.env.SUPABASE_SERVICE_ROLE_KEY || process.env.SUPABASE_ANON_KEY
        );

        // 3) insert
        savedAttempted = true;
        const rows = [
          {
            session_id: sessionId,
            role: 'user',
            content: SAVE_TEXT ? text : null,
            tags: userTags,
            meta: { len: text?.length || 0 }
          },
          {
            session_id: sessionId,
            role: 'assistant',
            content: SAVE_TEXT ? reply : null,
            tags: assistantTags,
            meta: { usedOpenAI, openai_error, len: reply?.length || 0 }
          }
        ];

        const { error } = await sb.from('messages').insert(rows);
        if (error) throw error;
        saved = true;
      } catch (e) {
        supabase_error = e?.message || String(e);
      }
    }

    return respond({
      ok: true,
      stage: 4.1,
      sessionId,
      message: reply,
      usedOpenAI,
      openai_error,
      saved,
      savedAttempted,
      supabase_error,
      envFlags,
      moduleSupabase,
      privacy: { savedText: SAVE_TEXT }
    });
  } catch (e) {
    return res.status(200).json({ ok: false, stage: 4.1, error: e?.message || 'server error' });
  }
}
