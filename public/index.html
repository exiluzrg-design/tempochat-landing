# Estructura propuesta

```
/
├─ index.html                ← Usa el HTML que compartiste (con cierre automático)
├─ api/
│  ├─ chat.js               ← Endpoint principal con memoria en Supabase + expiración
│  ├─ session.js            ← Extender (+5m) o finalizar (borrado)
│  └─ test-supabase.js      ← Ping conexión
├─ public/
│  └─ test.html             ← Probador mínimo /api/chat
├─ package.json             ← Node 20.x
└─ vercel.json (opcional)
```

---

## index.html (script con **cierre automático**, **anti-doble-cierre** y **mini‑banner “Cierre en curso…”**)

```html
<script>
  // Elementos
  let currentReqId = 0;
  const $ = (id) => document.getElementById(id);
  const chatlog = $('chatlog');
  const typing = $('typing');
  const errorBox = $('error');
  const input = $('msg');
  const btn = $('send');
  const timerEl = $('timer');
  const nudge = $('nudge');
  const btnAddTime = $('addTime');
  const btnWrap = $('wrapUp');
  const closingBanner = $('closingBanner'); // << mini‑banner

  // Temporizador
  let sessionSeconds = 600; // 10 minutos
  let interval; let askedAtNine = false;

  // Estado de cierre para evitar doble-conclusión
  let closing = false; // true si ya se está cerrando o se cerró

  function fmt(t){ const m=Math.floor(t/60); const s=String(t%60).padStart(2,'0'); return `${m}:${s}`; }
  function updateTimer(){ timerEl.textContent = `Tiempo restante: ${fmt(sessionSeconds)}`; }
  function startTimer(){
    clearInterval(interval); updateTimer();
    interval = setInterval(async ()=>{
      sessionSeconds = Math.max(sessionSeconds - 1, 0);
      updateTimer();
      if(sessionSeconds===60 && !askedAtNine){
        askedAtNine = true;
        nudge.style.display = 'flex';
        addMessage('assistant','Queda 1 minuto. ¿Sumamos 5 minutos o preferís cerrar con una conclusión/reflexión?');
      }
      if(sessionSeconds===0){
        clearInterval(interval);
        nudge.style.display = 'none';
        await requestClose('timeout');
      }
    },1000);
  }
  startTimer();

  // Utilidades UI
  function setTyping(on){ typing.style.display = on ? 'block' : 'none'; }
  function showError(msg){ errorBox.style.display='block'; errorBox.textContent = typeof msg==='string'? msg : JSON.stringify(msg); }
  function clearError(){ errorBox.style.display='none'; errorBox.textContent=''; }
  function addMessage(role,text){ const d=document.createElement('div'); d.className='msg '+role; d.textContent=String(text||''); chatlog.appendChild(d); chatlog.scrollTop = chatlog.scrollHeight; }

  // Sesión (frontend)
  function getSessionId(){ return localStorage.getItem('tempochat.sid') || ''; }
  function setSessionId(id){ if(id) localStorage.setItem('tempochat.sid', id); }
  function safeJson(t){ try{ return JSON.parse(t); }catch{ return { raw:t }; } }

  // Helpers de cierre
  function setClosing(on){
    closing = on;
    if(closingBanner) closingBanner.style.display = on ? 'block' : 'none';
    // Bloqueo de la UI y oculto nudge siempre que se está cerrando
    input.disabled = on; btn.disabled = on; nudge.style.display = 'none';
  }

  // Backend helpers
  async function extendSession(minutes=5){
    const r = await fetch('/api/session',{ method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ op:'extend', sessionId: getSessionId(), minutes }) });
    const txt = await r.text(); const j = safeJson(txt);
    if(!r.ok){ showError(j?.message||txt); return null; }
    return j;
  }
  async function endSession(){
    const sid = getSessionId(); if(!sid) return;
    try{
      await fetch('/api/session',{ method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ op:'end', sessionId: sid }) });
    }catch{}
    localStorage.removeItem('tempochat.sid');
  }

  // Chat
  async function send(text){
    const reqId = ++currentReqId; clearError(); setTyping(true);
    const controller = new AbortController(); const to = setTimeout(()=>controller.abort(), 30000);
    try{
      const res = await fetch('/api/chat',{
        method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ text, sessionId: getSessionId() }), signal: controller.signal
      });
      const raw = await res.text(); const json = safeJson(raw);
      if(reqId===currentReqId) setTyping(false);
      if(!res.ok){ showError(json?.message || json?.error || raw); return; }
      const reply = json.message || json.assistant || json.reply || json.output || raw;
      if(json.sessionId) setSessionId(json.sessionId);
      addMessage('assistant', reply);
    }catch(e){ if(reqId===currentReqId) setTyping(false); showError(e?.name==='AbortError' ? 'timeout' : (e?.message||'error')); }
    finally{ clearTimeout(to); }
  }

  // Solicitud de cierre unificado (manual o automático)
  async function requestClose(source){
    if(closing) return; // evita doble cierre
    setClosing(true);
    try{
      if(source === 'manual'){
        addMessage('user','Hagamos un cierre.');
      } else {
        addMessage('assistant','⏳ La sesión terminó. Preparando un cierre automático...');
      }
      const cierre = 'Generá un cierre breve con la conclusión principal y una reflexión de lo charlado.';
      await send(cierre);
      await endSession();
    }catch(e){ showError(e?.message||'error cierre'); }
  }

  // Envío manual
  btn.addEventListener('click', ()=>{ const v=input.value.trim(); if(!v) return; addMessage('user', v); input.value=''; send(v); });
  input.addEventListener('keydown', (e)=>{ if(e.key==='Enter') btn.click(); });

  // Acciones minuto 9
  btnAddTime.addEventListener('click', async ()=>{
    const resp = await extendSession(5);
    if(resp && resp.expiresAt){
      sessionSeconds += 5*60; // UI
      nudge.style.display = 'none';
      addMessage('system','Se agregaron 5 minutos a la sesión.');
    }
  });
  btnWrap.addEventListener('click', async ()=>{
    nudge.style.display = 'none';
    await requestClose('manual');
  });
</script>
```

### CSS + HTML que tenés que sumar (mínimo)
Agregá la clase y el contenedor del banner cerca del final del `<body>` o dentro de `.wrap`:

```html
<style>
  .closing-banner{ position:fixed; left:0; right:0; bottom:20px; margin:0 auto; max-width:1080px; background:#1b1b20; border:1px solid var(--line); border-radius:12px; padding:10px 14px; color:var(--muted); text-align:center; display:none; box-shadow:0 8px 24px rgba(0,0,0,.3); }
</style>

<div id="closingBanner" class="closing-banner">Cierre en curso… generando conclusión final</div>
```

---

## Cambios clave
- **`autoClose()`**: al llegar a `00:00`, manda un mensaje de cierre al backend (`send(cierre)`), recibe la conclusión de la IA y recién después borra la sesión.
- El usuario ve un aviso “⏳ La sesión terminó. Preparando un cierre automático...” mientras llega la respuesta.

Así, toda sesión termina con una **reflexión final automática de la IA**, incluso si el usuario no toca el botón de cierre. ✅
